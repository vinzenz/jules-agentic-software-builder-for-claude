import logging
from pathlib import Path
from typing import Dict

from agentic_builder.agents.configs import get_agent_config, get_agent_prompt
from agentic_builder.common.events import EventEmitter
from agentic_builder.common.types import Artifact, WorkflowStatus
from agentic_builder.orchestration.session_manager import SessionManager
from agentic_builder.orchestration.workflows import WorkflowMapper
from agentic_builder.pms.context_serializer import ContextSerializer


class WorkflowEngine(EventEmitter):
    def __init__(self, session_manager: SessionManager, pms_manager, git_manager, claude_client, pr_manager):
        super().__init__()
        self.session_manager = session_manager
        self.pms = pms_manager
        self.git = git_manager
        self.claude = claude_client
        self.pr_manager = pr_manager
        self._active_runs: Dict[str, bool] = {}

    def start_workflow(self, workflow_name: str) -> str:
        session = self.session_manager.create_session(workflow_name)
        self.session_manager.update_status(session.id, WorkflowStatus.RUNNING)
        self._active_runs[session.id] = True
        self.emit("workflow_started", session.id)

        # Create git branch
        branch_name = f"feature/{session.id}"
        try:
            self.git.create_branch(branch_name)
        except Exception:
            # Maybe branch exists, try to checkout
            try:
                self.git.checkout_branch(branch_name)
            except Exception as e:
                # If we can't switch to the branch, we shouldn't proceed
                # as we might pollute the wrong branch.
                raise Exception(f"Failed to create or switch to branch {branch_name}: {e}")

        try:
            self.run_loop(session.id)
        except Exception as e:
            self.session_manager.update_status(session.id, WorkflowStatus.FAILED)
            self.emit("workflow_failed", {"id": session.id, "error": str(e)})
            raise e

        return session.id

    def run_loop(self, session_id: str):
        session = self.session_manager.load_session(session_id)

        # Setup logging
        log_file = self.session_manager.session_dir / f"{session_id}.log"

        # Avoid clobbering global logging config by attaching handler directly to this logger
        logger = logging.getLogger(session_id)
        logger.setLevel(logging.INFO)

        # Remove existing handlers to avoid duplicates if reused
        if logger.hasHandlers():
            logger.handlers.clear()

        file_handler = logging.FileHandler(log_file)
        formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)

        logger.info(f"Starting workflow loop for {session_id}")

        # Determine execution order based on workflow name
        try:
            execution_order = WorkflowMapper.get_execution_order(session.workflow_name)
        except Exception:
            # Fallback to full generation if mapping fails or handle error
            execution_order = WorkflowMapper.get_execution_order("FULL_APP_GENERATION")

        # Resume logic: skip completed agents
        completed_agents = set()
        # Map AgentType -> TaskID for dependency resolution
        agent_task_map = {}

        for task_id in session.completed_tasks:
            t = self.pms.get_task(task_id)
            if t:
                completed_agents.add(t.agent_type)
                agent_task_map[t.agent_type] = task_id

        for agent_type in execution_order:
            if session_id not in self._active_runs:
                break  # Cancelled

            if agent_type in completed_agents:
                continue

            config = get_agent_config(agent_type)

            # 1. Create PMS Task
            # Resolve dependencies task IDs
            deps_ids = []
            for dep_agent in config.dependencies:
                # Look for the task ID corresponding to this dependent agent in the current session
                if dep_agent in agent_task_map:
                    deps_ids.append(agent_task_map[dep_agent])

            task = self.pms.create_task(
                description=f"Execute {agent_type.value} phase",
                agent_type=agent_type,
                dependencies=deps_ids,
            )

            self.emit("agent_spawned", {"agent": agent_type, "task_id": task.id})
            logger.info(f"Spawned agent {agent_type} (Task {task.id})")

            # 2. Serialize Context
            # Gather artifacts from dependencies
            # We assume artifacts are stored in context_files (paths) or we need to look them up.
            # For this implementation, we will look up the artifacts generated by previous tasks.
            # But Task object doesn't store generated artifacts list.
            # We will use the Session checkpoints or just files on disk.
            # Ideally, PMS should track artifacts.
            # Let's read files from the task's context_files if any, or rely on file system state.
            # The context serializer expects `dep_outputs: Dict[str, List[Artifact]]`.

            # Pass file paths from dependencies (not content - agents read files directly)
            dep_outputs = {}
            for dep_id in task.dependencies:
                dt = self.pms.get_task(dep_id)
                if dt and dt.context_files:
                    # Just pass file paths - agents will read files themselves if needed
                    arts = []
                    for fpath in dt.context_files:
                        try:
                            p = Path(fpath)
                            if p.exists() and p.is_file():
                                arts.append(Artifact(name=p.name, type="file", path=str(p)))
                        except Exception:
                            pass
                    dep_outputs[dep_id] = arts

            # Serialize
            context_xml = ContextSerializer.serialize(task, dep_outputs)

            # 3. Call Claude
            # Pass the task description as the prompt (-p)
            prompt = task.description
            response = self.claude.call_agent(
                agent_type=agent_type, prompt=prompt, user_input=context_xml, model=config.model_tier
            )

            # 4. Handle Response
            # Agents write files directly to disk - we just track what was created/modified
            if response.success:
                created_files = []
                for artifact in response.artifacts:
                    if artifact.type == "file" and artifact.path:
                        # New format: agent already wrote file, we just validate and track
                        fpath = Path(artifact.path).resolve()
                        root_path = Path.cwd().resolve()

                        if not fpath.is_relative_to(root_path):
                            logger.error(f"Security: Agent reported file outside repo: {fpath}")
                            continue

                        # Verify file exists (agent should have created it)
                        if fpath.exists():
                            created_files.append(str(fpath))
                            logger.info(f"Agent {artifact.action or 'created'} file: {fpath}")
                        else:
                            logger.warning(f"Agent reported file but it doesn't exist: {fpath}")

                    elif artifact.type == "file" and artifact.content:
                        # Legacy fallback: write content if provided (backwards compatibility)
                        fpath = Path(artifact.name).resolve()
                        root_path = Path.cwd().resolve()

                        if not fpath.is_relative_to(root_path):
                            logger.error(f"Security: Attempted path traversal write to {fpath}")
                            continue

                        if fpath.parent:
                            fpath.parent.mkdir(parents=True, exist_ok=True)
                        fpath.write_text(artifact.content)
                        created_files.append(str(fpath))

                # Update task with created files so next agents can see them
                task.context_files = created_files
                task.status = "completed"
                self.pms.save_task(task)

                session.completed_tasks.append(task.id)
                session.total_tokens += response.metadata.get("tokensUsed", 0)
                # Update local map for subsequent agents in this loop
                completed_agents.add(agent_type)
                agent_task_map[agent_type] = task.id

                self.session_manager.save_session(session)

                # Commit
                if created_files:
                    self.git.commit_files(created_files, f"[{agent_type.value}] {response.summary[:50]}")

                self.emit("agent_completed", {"agent": agent_type, "summary": response.summary})
                logger.info(f"Agent {agent_type} completed.")
            else:
                self.emit("agent_failed", {"agent": agent_type, "error": response.summary})
                logger.error(f"Agent {agent_type} failed: {response.summary}")
                raise Exception(f"Agent {agent_type} failed: {response.summary}")

        # Finish
        if session_id in self._active_runs:
            self.session_manager.update_status(session.id, WorkflowStatus.COMPLETED)
            del self._active_runs[session_id]

            # Create PR
            self.pr_manager.create_pr(
                branch=f"feature/{session.id}",
                title=f"Workflow {session.workflow_name}",
                body="Generated by Agentic Mobile App Builder",
            )
            self.emit("workflow_completed", session.id)

    def get_run(self, run_id: str):
        return self._active_runs.get(run_id)

    def cancel_workflow(self, run_id: str):
        if run_id in self._active_runs:
            del self._active_runs[run_id]
        self.session_manager.update_status(run_id, WorkflowStatus.CANCELLED)
